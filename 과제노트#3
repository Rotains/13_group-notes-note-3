4주차 토론
혼자 해 보기 4-1
처음 a = b++했을 때 ++가 b뒤에 붙으므로 a = 10,  b= 11이 나온다고 생각했고 직접 실행후 값이 똑같이 나왔다.

그 후

d = ++a했을 때 이번에는 ++가 a의 앞에 있으므로 a의 값에 먼저 1을 더하기때문에 d = 11이라고 생각후 이것도 실행결과 d = 11이 나왔다.

마지막

a = b + ++d 실행했을 때 b의 값은 11이고 d의 값도 11인데 ++가 d의 앞에 있으므로 d = 12가 되기때문에 최종적으로 a의 값은 23이 나올 거라고 생각했고 이후 실행 결과 a = 23이 나와 우리 생각대로 잘 맞아 떨어졌다.
여기서 수식이 a = ++d + b로 순서가 바뀌게 되면 +b는 계산되지않고 a = ++d만 연산이 되나?라는 생각이 들어 직접 바꾸어서 했더니 결과값은 그래도 똑같이 나왔다. a = ++b 등 단순 연산기호만 있으면 바로 값이 대입되어 계산되고 
나머지는 수식 순서대로 계산이 되는 것 같다. 

예제 4-3

int a = 20, b = 3, c = 7, d, e; 플로트 f = 15.0, g;

처음 d = a / b 할 때 /는 몫을 구하는 의미로 20 / 3 = 6이 나오며, 나머지는 출력되지 않는다.

e = a % c 할 때 %는 나머지를 구하는 의미로 20 / 7 = 2···6 나머지 값이 6이 나오며, 몫은 출력되지 않는다.

g = f / c 할땐 15.0 / 7 이고 마지막 프린트 문에서 %f로 출력하니 2.142857로 값이 나왔다. %f값때문에 몫인 2 외에도 소수점까지도 나타난 것으로 보인다고 판단하였다.

혼자 해 보기 4 - 2
삼각형의 넓이를 구하는 공식을 작성해보았다.
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)

{
	int length, height, area; // 정사각형과 달리 삼각형은 높이가 필요해 추가로 넣었다.
	printf("삼각형 밑변의 길이와 높이를 입력하시오.\n"); 
	scanf("%d", &length); // 삼각형 밑변의 길이 값
	scanf("%d", &height); // 삼각형 높이 값

	area = length * height *0.5; // 삼각형의 공식인 밑변x높이/2 /2대신 *0.5로 수정해 넣었다. 같은 값이기 때문에 곱셈으로 편하게 보이려고 수정하였다. 
	printf("삼각형의 넓이는 %d이다. \n", area);

	return 0;
}

비트값 연산해보기
AND와 OR 연산 10진수 15까지 2진수로 바꿔 직접 연산 해본내용
0 = 0000 | 1111 = 1111 / 1 = 0001 & 1101 = 0001 / 2 = 0010 & 0111 = 0010 / 3 = 0011 | 1010 = 1011 / 4 = 0100 | 0111 = 0111 / 5 = 0101 | 0101 = 0101 / 6 = 0110 & 1000 = 0000 
7 = 0111 & 0001 = 0001 / 8 = 1000 & 1100 = 1000 / 9 = 1001 | 0110 = 1111 / 10 = 1010 & 1101 = 1000 / 11 = 1011 | 1011 = 1011 / 12 = 1100 | 0000 = 1100 / 13 = 1101 & 0101 = 0101 / 14 = 1110 & 1001 = 1001 / 15 = 1111 & 0100 = 0100

160과 1의 비트곱을 구해보자
먼저 10진수 160을 2진수로 바꾸어보자
128 64 32 16 8 4 2 1 

1 0 1 0 0 0 0 0 = 160

10100000 = 160

00000001 = 1 & 10100000 = 160

= 00000000 그래서 비트값은 0이다.

128과 160의 비트곱을 구해보자
10000000 = 128 & 10100000 = 160

= 10000000 따라서 비트값은 128이다.

shift 연산 
14 >> 2 / 12 >> 2는 왜 값이 같은 걸까?
14 = 1110  오른쪽으로 두비트 이동하면 0011 연산 결과3
12 = 1100  오른쪽으로 두비트 이동하면 0011 연산 결과3
연산식이 a / 2^b인데 정수형이므로 소수점은 없어지기 때문에 값이 같아진다.


예제 4-12

x가 15인 이유는

x = (y = 5, y + 10) 부분에서 y를 5로 끌어들이고 콤마가 인터셉트서 다음 문장인 y + 10을 실행하여 y의 값은 콤마 y = 5로인해 값이 5 먼저 실행된 후 y + 10 실행해 5 +10 = 15가 x에 들어간다 그러므로 x = 15

y가 5인 이유는

x = (y = 5, y + 10),y) 부분에서 x가 15의 값을 수식하기전 y = 5라고 해서 y의 값에 5가 들어온 온것이다. 뒤에있는 y + 10은 x의 값에 대입되는 것이니 x = 15, y = 5가 되는것이다.
여기서 우리가 알게된 내용은 괄호안의 콤마는 앞에것을 수행하고 뒤에것을 처리하게 된다는 것을 배웠다.
이를 응용해서 괄호의 위치를 한 번 조절해보고 계산을 했더니 printf("x = %d, y = %d\n", x = y = 5, (y + 10), y); 결과값이 x=5 y=15 확실히 달라진다는 것을 알게 되었다.
이로 인해 연산자속 먼저 계산할 게 있으면 괄호를 잘 활용하여야겠다.

